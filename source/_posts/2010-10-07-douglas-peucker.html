---
layout: post
title: 道格拉斯-普克抽稀算法
categories:
- 开发
- python
tags:
- Douglas-Peucker
published: true
comments: true
---
<p><p>道格拉斯-普克抽稀(Douglas-Peucker)算法是一个常用的线抽稀算法，将一条线在不改变大概形状的情况下，使用最少数量的点描述。基本原理如下图：</p>
<img alt="http://farm5.static.flickr.com/4128/5059015147_9dbced272a_m.jpg" src="http://farm5.static.flickr.com/4128/5059015147_9dbced272a_m.jpg" />
<p>通过Google我找到了两段代码，一段是c#的，一段是python的。现将其分享出来</p>
<p>C#版的:</p>
<pre class="literal-block">
/// &lt;summary&gt;
/// Uses the Douglas Peucker algorithm to reduce the number of points.
/// &lt;/summary&gt;
/// &lt;param name=&quot;Points&quot;&gt;The points.&lt;/param&gt;
/// &lt;param name=&quot;Tolerance&quot;&gt;The tolerance.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static List&lt;Point&gt; DouglasPeuckerReduction
(List&lt;Point&gt; Points, Double Tolerance)
{
if (Points == null || Points.Count &lt; 3)
return Points;
Int32 firstPoint = 0;
Int32 lastPoint = Points.Count - 1;
List&lt;Int32&gt; pointIndexsToKeep = new List&lt;Int32&gt;();
//Add the first and last index to the keepers
pointIndexsToKeep.Add(firstPoint);
pointIndexsToKeep.Add(lastPoint);
//The first and the last point cannot be the same
while (Points[firstPoint].Equals(Points[lastPoint]))
{
lastPoint--;
}
DouglasPeuckerReduction(Points, firstPoint, lastPoint,
Tolerance, ref pointIndexsToKeep);
List&lt;Point&gt; returnPoints = new List&lt;Point&gt;();
pointIndexsToKeep.Sort();
foreach (Int32 index in pointIndexsToKeep)
{
returnPoints.Add(Points[index]);
}
return returnPoints;
}
/// &lt;summary&gt;
/// Douglases the peucker reduction.
/// &lt;/summary&gt;
/// &lt;param name=&quot;points&quot;&gt;The points.&lt;/param&gt;
/// &lt;param name=&quot;firstPoint&quot;&gt;The first point.&lt;/param&gt;
/// &lt;param name=&quot;lastPoint&quot;&gt;The last point.&lt;/param&gt;
/// &lt;param name=&quot;tolerance&quot;&gt;The tolerance.&lt;/param&gt;
/// &lt;param name=&quot;pointIndexsToKeep&quot;&gt;The point index to keep.&lt;/param&gt;
private static void DouglasPeuckerReduction(List&lt;Point&gt;
points, Int32 firstPoint, Int32 lastPoint, Double tolerance,
ref List&lt;Int32&gt; pointIndexsToKeep)
{
Double maxDistance = 0;
Int32 indexFarthest = 0;
for (Int32 index = firstPoint; index &lt; lastPoint; index++)
{
Double distance = PerpendicularDistance
(points[firstPoint], points[lastPoint], points[index]);
if (distance &gt; maxDistance)
{
maxDistance = distance;
indexFarthest = index;
}
}
if (maxDistance &gt; tolerance &amp;&amp; indexFarthest != 0)
{
//Add the largest point that exceeds the tolerance
pointIndexsToKeep.Add(indexFarthest);
DouglasPeuckerReduction(points, firstPoint,
indexFarthest, tolerance, ref pointIndexsToKeep);
DouglasPeuckerReduction(points, indexFarthest,
lastPoint, tolerance, ref pointIndexsToKeep);
}
}
/// &lt;summary&gt;
/// The distance of a point from a line made from point1 and point2.
/// &lt;/summary&gt;
/// &lt;param name=&quot;pt1&quot;&gt;The PT1.&lt;/param&gt;
/// &lt;param name=&quot;pt2&quot;&gt;The PT2.&lt;/param&gt;
/// &lt;param name=&quot;p&quot;&gt;The p.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public static Double PerpendicularDistance
(Point Point1, Point Point2, Point Point)
{
//Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
//Base = v((x1-x2)2+(x1-x2)2)                               *Base of Triangle*
//Area = .5*Base*H                                          *Solve for height
//Height = Area/.5/Base
Double area = Math.Abs(.5 * (Point1.X * Point2.Y + Point2.X *
Point.Y + Point.X * Point1.Y - Point2.X * Point1.Y - Point.X *
Point2.Y - Point1.X * Point.Y));
Double bottom = Math.Sqrt(Math.Pow(Point1.X - Point2.X, 2) +
Math.Pow(Point1.Y - Point2.Y, 2));
Double height = area / bottom * 2;
return height;
//Another option
//Double A = Point.X - Point1.X;
//Double B = Point.Y - Point1.Y;
//Double C = Point2.X - Point1.X;
//Double D = Point2.Y - Point1.Y;
//Double dot = A * C + B * D;
//Double len_sq = C * C + D * D;
//Double param = dot / len_sq;
//Double xx, yy;
//if (param &lt; 0)
//{
//    xx = Point1.X;
//    yy = Point1.Y;
//}
//else if (param &gt; 1)
//{
//    xx = Point2.X;
//    yy = Point2.Y;
//}
//else
//{
//    xx = Point1.X + param * C;
//    yy = Point1.Y + param * D;
//}
//Double d = DistanceBetweenOn2DPlane(Point, new Point(xx, yy));
}
</pre>
<p>python 版的:</p>
<pre class="literal-block">
# pure-Python Douglas-Peucker line simplification/generalization
#
# this code was written by Schuyler Erle &lt;schuyler&#64;nocat.net&gt; and is
#   made available in the public domain.
#
# the code was ported from a freely-licensed example at
#   http://www.3dsoftware.com/Cartography/Programming/PolyLineReduction/
#
# the original page is no longer available, but is mirrored at
#   http://www.mappinghacks.com/code/PolyLineReduction/
&quot;&quot;&quot;
&gt;&gt;&gt; line = [(0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,1),(0,0)]
&gt;&gt;&gt; simplify_points(line, 1.0)
[(0, 0), (2, 0), (2, 2), (0, 2), (0, 0)]
&gt;&gt;&gt; line = [(0,0),(0.5,0.5),(1,0),(1.25,-0.25),(1.5,.5)]
&gt;&gt;&gt; simplify_points(line, 0.25)
[(0, 0), (0.5, 0.5), (1.25, -0.25), (1.5, 0.5)]
&quot;&quot;&quot;
import math
def simplify_points (pts, tolerance):
anchor  = 0
floater = len(pts) - 1
stack   = []
keep    = set()
stack.append((anchor, floater))
while stack:
anchor, floater = stack.pop()
# initialize line segment
if pts[floater] != pts[anchor]:
anchorX = float(pts[floater][0] - pts[anchor][0])
anchorY = float(pts[floater][1] - pts[anchor][1])
seg_len = math.sqrt(anchorX ** 2 + anchorY ** 2)
# get the unit vector
anchorX /= seg_len
anchorY /= seg_len
else:
anchorX = anchorY = seg_len = 0.0
# inner loop:
max_dist = 0.0
farthest = anchor + 1
for i in range(anchor + 1, floater):
dist_to_seg = 0.0
# compare to anchor
vecX = float(pts[i][0] - pts[anchor][0])
vecY = float(pts[i][1] - pts[anchor][1])
seg_len = math.sqrt( vecX ** 2 + vecY ** 2 )
# dot product:
proj = vecX * anchorX + vecY * anchorY
if proj &lt; 0.0:
dist_to_seg = seg_len
else:
# compare to floater
vecX = float(pts[i][0] - pts[floater][0])
vecY = float(pts[i][1] - pts[floater][1])
seg_len = math.sqrt( vecX ** 2 + vecY ** 2 )
# dot product:
proj = vecX * (-anchorX) + vecY * (-anchorY)
if proj &lt; 0.0:
dist_to_seg = seg_len
else:  # calculate perpendicular distance to line (pythagorean theorem):
dist_to_seg = math.sqrt(abs(seg_len ** 2 - proj ** 2))
if max_dist &lt; dist_to_seg:
max_dist = dist_to_seg
farthest = i
if max_dist &lt;= tolerance: # use line segment
keep.add(anchor)
keep.add(floater)
else:
stack.append((anchor, farthest))
stack.append((farthest, floater))
keep = list(keep)
keep.sort()
return [pts[i] for i in keep]
if __name__ == &quot;__main__&quot;:
import doctest
doctest.testmod()
</pre>
</p>
